<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Interactive Oblique Mercator (Mono)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <style>
        /* 背景を白、文字を黒に変更 */
        body { margin: 0; overflow: hidden; background: #ffffff; color: #000; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; cursor: grab; }
        canvas:active { cursor: grabbing; }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            /* パネルも見やすいように白背景・グレー枠線に変更 */
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ccc;
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        /* キーワードの色を濃い青などに変更（白背景で目立つように） */
        .key { color: #0056b3; font-weight: bold; }
    </style>
</head>
<body>

<div class="controls">
    <div><span class="key">ドラッグ</span> : 中心位置の移動</div>
    <div><span class="key">Shift + ドラッグ</span> : 地図の回転 (斜軸角度)</div>
    <div><span class="key">ホイール</span> : ズーム</div>
    <div id="status" style="margin-top: 10px; font-size: 0.9em; color: #555;">
        Rotate: [0, 0, 0]
    </div>
</div>

<canvas id="globe"></canvas>

<script>
    const canvas = document.getElementById("globe");
    const context = canvas.getContext("2d");
    const statusDiv = document.getElementById("status");

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    const projection = d3.geoMercator()
        .translate([width / 2, height / 2])
        .scale((width / 2) / Math.PI); 

    const path = d3.geoPath(projection, context);

    let rotation = [135, -35, 0]; 
    projection.rotate(rotation);

    let landData = null;
    let borderData = null;

    // データ読み込み (正しい countries-110m.json を使用)
    d3.json("https://unpkg.com/world-atlas@2/countries-110m.json").then(data => {
        // 陸地全体
        landData = topojson.feature(data, data.objects.land);
        
        // 国境線（内部境界のみ）
        // 海岸線と重複しないよう、topojson.mesh で a !== b のフィルタをかけます
        borderData = topojson.mesh(data, data.objects.countries, (a, b) => a !== b);
        
        render();
    });

    const drag = d3.drag()
        .subject(() => {
            const r = projection.rotate();
            return { x: r[0], y: -r[1], gamma: r[2] };
        })
        .on("drag", (event) => {
            const rotate = projection.rotate();
            
            if (event.sourceEvent.shiftKey) {
                let newGamma = event.subject.gamma + (event.x - event.subject.x) * 0.5;
                rotation = [rotate[0], rotate[1], newGamma];
            } else {
                const k = 75 / projection.scale(); 
                let newLambda = rotate[0] + event.dx * k;
                let newPhi = rotate[1] - event.dy * k;
                newPhi = Math.max(-85, Math.min(85, newPhi));
                rotation = [newLambda, newPhi, rotate[2]];
            }

            projection.rotate(rotation);
            render();
        });

    const zoom = d3.zoom()
        .scaleExtent([50, 5000])
        .on("zoom", (event) => {
            projection.scale(event.transform.k);
            render();
        });

    d3.select(canvas)
        .call(drag)
        .call(zoom)
        .call(zoom.transform, d3.zoomIdentity.translate(width / 2, height / 2).scale(projection.scale()).translate(-width / 2, -height / 2));

    function render() {
        if (!landData) return;

        context.clearRect(0, 0, width, height);

        // 1. 海（背景）: White
        context.fillStyle = "#ffffff";
        context.fillRect(0, 0, width, height);

        // 2. グリッド線: Gray (薄め)
        context.beginPath();
        path(d3.geoGraticule()());
        context.strokeStyle = "#cccccc"; // 薄いグレー
        context.lineWidth = 0.5;
        context.stroke();

        // 3. 陸地: Black
        context.beginPath();
        path(landData);
        context.fillStyle = "#000000"; // 真っ黒
        context.fill();
        // 陸地の輪郭を描画するかどうか
        // 黒塗りつぶしの場合、輪郭なしでもOKですが、ズレ防止のため同色で描画しておきます
        context.strokeStyle = "#000000"; 
        context.lineWidth = 0.5;
        context.stroke();

        // 4. 国境線: Gray (陸地が黒なので、白っぽいグレーか、あるいは見えなくて良ければ描画しない)
        // ★ 陸地が黒(#000)の場合、黒の上にグレーの線を引いても見にくいですが、
        //    「線はGray」というご要望のため、明るいグレーで描画します。
        if (borderData) {
            context.beginPath();
            path(borderData);
            context.strokeStyle = "#888888"; // 陸地(黒)の上に乗るので、少し明るめのグレー
            context.lineWidth = 0.5;
            context.stroke();
        }
        
        const r = projection.rotate();
        statusDiv.innerText = `Rotate: [${r[0].toFixed(1)}, ${r[1].toFixed(1)}, ${r[2].toFixed(1)}] (Shift+Drag to roll)`;
    }

    window.addEventListener("resize", () => {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        projection.translate([width / 2, height / 2]);
        render();
    });

</script>
</body>
</html>
