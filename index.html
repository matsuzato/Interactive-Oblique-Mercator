<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Interactive Oblique Mercator</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; color: white; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; cursor: grab; }
        canvas:active { cursor: grabbing; }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none; /* マウスイベントを下のCanvasに通す */
        }
        .key { color: #4db8ff; font-weight: bold; }
    </style>
</head>
<body>

<div class="controls">
    <div><span class="key">ドラッグ</span> : 中心位置の移動</div>
    <div><span class="key">Shift + ドラッグ</span> : 地図の回転 (斜軸角度)</div>
    <div><span class="key">ホイール</span> : ズーム</div>
    <div id="status" style="margin-top: 10px; font-size: 0.9em; color: #aaa;">
        Rotate: [0, 0, 0]
    </div>
</div>

<canvas id="globe"></canvas>

<script>
    const canvas = document.getElementById("globe");
    const context = canvas.getContext("2d");
    const statusDiv = document.getElementById("status");

    // 【修正1】初期サイズを正しく取得し、Canvasの内部解像度にも適用する
    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    // 1. 投影法の定義
    const projection = d3.geoMercator()
        .translate([width / 2, height / 2])
        .scale((width / 2) / Math.PI); 

    const path = d3.geoPath(projection, context);

    // 状態変数
    let rotation = [135, -35, 0]; // 初期値: 日本付近
    projection.rotate(rotation);

    let landData = null;

    // 2. 地図データの読み込み
    d3.json("https://unpkg.com/world-atlas@2/land-110m.json").then(data => {
        landData = topojson.feature(data, data.objects.land);
        render();
    });

    // 3. ドラッグ & ズーム挙動
    const drag = d3.drag()
        .subject(() => {
            const r = projection.rotate();
            return { x: r[0], y: -r[1], gamma: r[2] };
        })
        .on("drag", (event) => {
            const rotate = projection.rotate();
            
            if (event.sourceEvent.shiftKey) {
                // Shift + ドラッグ: 第3軸（Gamma/Roll）回転 = 斜軸成分の変更
                let newGamma = event.subject.gamma + (event.x - event.subject.x) * 0.5;
                rotation = [rotate[0], rotate[1], newGamma];
            } else {
                // 通常ドラッグ: 中心位置移動
                const k = 75 / projection.scale(); 
                let newLambda = rotate[0] + event.dx * k;
                let newPhi = rotate[1] - event.dy * k;
                newPhi = Math.max(-85, Math.min(85, newPhi));
                rotation = [newLambda, newPhi, rotate[2]];
            }

            projection.rotate(rotation);
            render();
        });

    const zoom = d3.zoom()
        .scaleExtent([50, 5000])
        .on("zoom", (event) => {
            // D3 v7のzoomイベントからスケールを取得して適用
            projection.scale(event.transform.k);
            render();
        });

    d3.select(canvas)
        .call(drag)
        .call(zoom)
        // 初期ズームレベルを現在のprojection.scaleに合わせる
        .call(zoom.transform, d3.zoomIdentity.translate(width / 2, height / 2).scale(projection.scale()).translate(-width / 2, -height / 2));

    // 4. 描画ループ
    function render() {
        if (!landData) return;

        context.clearRect(0, 0, width, height);

        // 背景
        context.fillStyle = "#2a2a2a";
        context.fillRect(0, 0, width, height);

        // グリッド線
        context.beginPath();
        path(d3.geoGraticule()());
        context.strokeStyle = "#444";
        context.lineWidth = 0.5;
        context.stroke();

        // 陸地
        context.beginPath();
        path(landData);
        context.fillStyle = "#69b3a2";
        context.fill();
        context.strokeStyle = "#fff";
        context.lineWidth = 0.5;
        context.stroke();

        const r = projection.rotate();
        statusDiv.innerText = `Rotate: [${r[0].toFixed(1)}, ${r[1].toFixed(1)}, ${r[2].toFixed(1)}] (Shift+Drag to roll)`;
    }

    // リサイズ対応
    window.addEventListener("resize", () => {
        width = window.innerWidth;
        height = window.innerHeight;
        
        // 【修正2】リサイズ時にもCanvas解像度を更新
        canvas.width = width;
        canvas.height = height;
        
        projection.translate([width / 2, height / 2]);
        render();
    });

</script>
</body>
</html>
