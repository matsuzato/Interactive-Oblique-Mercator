<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Interactive Oblique Mercator</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; color: white; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; cursor: grab; }
        canvas:active { cursor: grabbing; }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none; /* マウスイベントを下のCanvasに通す */
        }
        .key { color: #4db8ff; font-weight: bold; }
    </style>
</head>
<body>

<div class="controls">
    <div><span class="key">ドラッグ</span> : 中心位置の移動</div>
    <div><span class="key">Shift + ドラッグ</span> : 地図の回転 (斜軸角度)</div>
    <div><span class="key">ホイール</span> : ズーム</div>
    <div id="status" style="margin-top: 10px; font-size: 0.9em; color: #aaa;">
        Rotate: [0, 0, 0]
    </div>
</div>

<canvas id="globe"></canvas>

<script>
    const canvas = document.getElementById("globe");
    const context = canvas.getContext("2d");
    const statusDiv = document.getElementById("status");

    let width = window.innerWidth;
    let height = window.innerHeight;

    // 1. 投影法の定義 (通常のメルカトルを使用)
    // 斜軸メルカトルは、メルカトルの球面を回転させることで表現します。
    const projection = d3.geoMercator()
        .translate([width / 2, height / 2])
        .scale((width / 2) / Math.PI); // 初期スケール

    const path = d3.geoPath(projection, context);

    // 状態変数
    let rotation = [135, -35, 0]; // 初期値: 日本付近、回転なし
    projection.rotate(rotation);

    let landData = null;

    // 2. 地図データの読み込み (World Atlas)
    d3.json("https://unpkg.com/world-atlas@2/land-110m.json").then(data => {
        landData = topojson.feature(data, data.objects.land);
        render();
    });

    // 3. ドラッグ & ズーム挙動の定義
    const drag = d3.drag()
        .subject(() => {
            const r = projection.rotate();
            return { x: r[0], y: -r[1], gamma: r[2] };
        })
        .on("drag", (event) => {
            const rotate = projection.rotate();
            
            if (event.sourceEvent.shiftKey) {
                // ---------------------------------------------------------
                // 【重要】Shiftキーが押されている場合: 第3軸（Gamma/Roll）を回転
                // これが「地図を回転させる方向の回転」にあたります。
                // ---------------------------------------------------------
                // X方向の動きを回転角度に反映
                let newGamma = event.subject.gamma + (event.x - event.subject.x) * 0.5;
                
                // 値を保持しつつ更新 ([yaw, pitch, roll])
                rotation = [rotate[0], rotate[1], newGamma];
            } else {
                // ---------------------------------------------------------
                // 通常ドラッグ: 中心座標（Yaw/Pitch）の移動
                // ---------------------------------------------------------
                // D3の標準的な挙動に合わせて感度を調整
                // メルカトル図法上で直感的に動かすため、スケールに応じた感度調整を入れるのが理想ですが
                // ここでは簡易的に固定感度で実装しています。
                const k = 75 / projection.scale(); 
                let newLambda = rotate[0] + event.dx * k;
                let newPhi = rotate[1] - event.dy * k;
                
                // 緯度の制限 (メルカトルは極で発散するため)
                newPhi = Math.max(-85, Math.min(85, newPhi));

                rotation = [newLambda, newPhi, rotate[2]];
            }

            projection.rotate(rotation);
            render();
        });

    // ズーム挙動
    const zoom = d3.zoom()
        .scaleExtent([50, 5000])
        .on("zoom", (event) => {
            projection.scale(event.transform.k);
            render();
        });

    // イベントリスナーの適用
    d3.select(canvas)
        .call(drag)
        .call(zoom)
        .call(zoom.transform, d3.zoomIdentity.scale(projection.scale()));

    // 4. 描画ループ
    function render() {
        if (!landData) return;

        // 画面クリア
        context.clearRect(0, 0, width, height);

        // 背景（海）
        context.fillStyle = "#2a2a2a";
        context.fillRect(0, 0, width, height);

        // グリッド線（回転がわかりやすいように表示）
        context.beginPath();
        path(d3.geoGraticule()());
        context.strokeStyle = "#444";
        context.lineWidth = 0.5;
        context.stroke();

        // 陸地
        context.beginPath();
        path(landData);
        context.fillStyle = "#69b3a2";
        context.fill();
        context.strokeStyle = "#fff";
        context.lineWidth = 0.5;
        context.stroke();
        
        // 地球の輪郭（クリップ領域の目安）
        // メルカトルは無限平面ですが、回転感覚をつかむため円を表示することもあります
        // 今回は全画面表示なので省略

        // ステータス表示更新
        const r = projection.rotate();
        statusDiv.innerText = `Rotate: [${r[0].toFixed(1)}, ${r[1].toFixed(1)}, ${r[2].toFixed(1)}] (Shift+Drag to roll)`;
    }

    // リサイズ対応
    window.addEventListener("resize", () => {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        projection.translate([width / 2, height / 2]);
        render();
    });

</script>
</body>
</html>
